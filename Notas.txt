Nueva idea es hacer un juego que sea como base para elaborar un sistema en el que los agentes sean capaces de manejar la economia y sean capaces de generar comportamientos emergentes

La idea es que los agentes aprendan sobre la marcha, que puedan establecer nuevas reglas sobre la marcha. (Buscar info sobre como programar comportamientos emergentes para que puedan "programarse 
a si mismo")

Las reglas pueden ser del tipo de si tienen x mateeriales pueden hacer distintas cosas, primero que jueguen con unas reglas "más estrictas" para tener una idea del funcionamiento principal.
Una vez tenga eso les puedo dar la posibilidad de hacer algo basado en la economia y unos objetivos

Ideas de la reunión:
--> Hacer las reglas como Objetos que fuese la accion que se va a realizar esa accion que haya distintos tipos de accion, medir la economia de la civilizacion como iba crececiendo.
(Tener una economía que vaya incrementando y decreciendo en función de los activos que tenga esa civilización si crece es algo positivo porque la civilización con mejor economía será la ganadora)

--> De tecnologías que permitieran hacer distintas cosas, metal y algun tipo de dinero 

Entorno en el que haya reglas para que estén compitiendo los agentes para que produzcan cosas y beneficios 
una cosa son las posibilidades y otras las oportunidades.

Exploracion la nave tenga una vision clara para que se puiedan ir mejorando con nuevas tecnologías
(Puedo hacer que puedan crear naves para la exploración y esas naves vean solo en una distancia determinada, es decir que no sepan ver más allá de x píxeles de la pantalla, una vez que descubran mejoras 
pueden aumentar los píxeles de visión para identificar planetas más alejados)

Los recursos son recursos para otros, la tecnología es un recurso para otro, es decir todo lo wue generan lo hacen para obtener otro beneficio ya sea más dinero o una manera de producir mas dinero 

Unas reglas básicas para puedes hacer estas cosas y esto servira para esto 

Tener un sistema de puntos económicos que  valore al que mas dinero tenga otro para cada tecnología que desarrollen, puntos para el  que más territorios tenga 


--  Mesa  -- Build an Agent-Based Simulation with Mesa video

- set up a bunch of players on a map 
- They play 10 rounds of the game tiyh eaxh of neighbors
- At the end of the round they look all of their neighbors and see who did the best and adopt their strategy 

Model is the enviroment and the agent is the one making decisions 
Decide which schedule model use, watch documentation  

from mesa import Agent, Model
from mesa.time import RandomActivation
from mesa.space import MultiGrid
from mesa.datacollection import DataCollector
from mesa.batchrunner import BatchRunner

# Un coeficiente para medir cuanto de injusto es un sistema 
def compute_gini(model):
    agent_wealths = [agent.wealth for agent in model.schedule.agents]
    x = sorted(agent_wealths)
    N = model.num_agents
    B = sum(xi * (N - i) for i, xi in enumerate(x)) / (N * sum(x))
    return (1 + (1 / N) - 2 * B)

class MoneyAgent(Agent):
    """An agent with hopes, dreams, and a mysterious past."""
    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        # Every agent starts with 1 money
        self.wealth = 1

    def step(self):
        self.move()
        if self.wealth > 0:
          self.give_money()

    def move(self):
        possible_steps = self.model.grid.get_neighborhood(
          self.pos,
          moore=False,
          include_center=True
        )
        new_position = self.random.choice(possible_steps)
        self.model.grid.move_agent(self, new_position)

    def give_money(self):
      cellmates = self.model.grid.get_cell_list_contents([self.pos])
      if len(cellmates) > 1:
        other = self.random.choice(cellmates)
        other.wealth += 1
        self.wealth -= 1


class MoneyModel(Model):
    """Our model--a home for our agents :"""
    def __init__(self, N, width, height):
        self.num_agents = N
        # A physical world to place our agents in 
        self.grid = MultiGrid(width, height, True)
        self.schedule = RandomActivation(self)
        self.running = True

        for i in range(self.num_agents):
          a = MoneyAgent(i, self)
          self.schedule.add(a)
          x = self.random.randrange(self.grid.width)  //Self.ramdom permte que todas las simulaciones sean con el mismo valor aleatorio
          y = self.random.randrange(self.grid.height)
          self.grid.place_agent(a, (x, y))

        # Some metrics we'll measure about our model
        self.datacollector = DataCollector(
            model_reporters={"Gini": compute_gini},
            agent_reporters={"Wealth": "wealth"},
        )

    def step(self):
        """Runs a single tick of the clock in our simulation."""
        self.datacollector.collect(self)
        self.schedule.step()

Posiciones del get_neighbors para determinar las posiciones de los estados del agentes
[(-1,-1), (-1,0), (-1,1), (0,-1),(0,1),(1,-1),(1,0),(1,1)]
diagonal inferior izquierda , izquierda, diagonal superior izquierda, abajo, arriba, diagonal inferior derecha, derecha, diagonal superior derecha
Osea next_moves = [LLD, L, ULD, D, U, LRD, R, URD]

moves = [(18, 9), (18, 10), (18, 11), (19, 9), (19, 11), (0, 9), (0, 10), (0, 11)]
action_space = {"LLD": 0, "L": 1, "ULD": 2, "D": 3, "U": 4, "LRD": 5, "R": 6, "URD": 7, "F": "Factory", "W": "Weapon"}
possible_actions = ["LLD", "L", "ULD", "D", "U", "LRD", "R", "URD", "F", "W"]
moves_action = ["LLD", "L", "ULD", "D", "U", "LRD", "R", "URD"]
action  = random.choice(list(action_space.keys()))
print(action)
if action in moves_action:
    print(moves[action_space.get(action)])

Como ejecutar de manera dinamica y cambiar atributos del modelo
Forma de modificar los atributos en ejecucion mediante los metodos exec, parecido a poner una condicion y ejecutarlo directamente
Para que funcione el codigo de exec tiene que estar pegado sin ningun tab ni espacio 

        if self.step_count % 10 == 0: 
            code = """
print(self.step_count)
for elemento in dir(self):
    print(elemento)
    # setattr(lista1, "producto" + str(i), elemento)
    
print(dir(self))

for i in dir(self):
    if i.startswith("_"):
        continue
    elif i == "list_agents":
        random_agent = self.__getattribute__(i)[0]
        random_agent.setAgentColor("black")
"""
            exec(code)

Formas de modificar un atributo desde un input.
# Ejemplo (M  nombre_var tipo_var valor) ó (A id(0-{}) nombre_var tipo_var valor): """.format(len(self.list_agents))).lower()
#             if new_atribute == "":
#                 pass
#             else:
#                 if re.match("^m\s[a-z(0-9)?]+\s(int|bool|float|str)\s[a-z0-9]+" + "|" + "^a\s[0-9]\s[a-z(0-9)?]+\s(int|bool|float|str)\s[a-z0-9]+",
#                             new_atribute):
#                     method_attributes = new_atribute.split()
#                     if len(method_attributes) == 5:
#                         self.addAttribute(class_name=method_attributes[0], attribute_name=method_attributes[2],
#                                         new_type=method_attributes[3], value=method_attributes[4], id=method_attributes[1])
#                     else:
#                         self.addAttribute(class_name=method_attributes[0], attribute_name=method_attributes[1],
#                                         new_type=method_attributes[2], value=method_attributes[3])
#                     print(self.__getattribute__(method_attributes[1]))
#             code = """
# print(self.step_count)
# setattr(self, "allies", False)

# print(dir(self))

# for i in dir(self):
#     if i.startswith("_"):
#         continue
#     elif i == "list_agents":
#         random_agent = self.__getattribute__(i)[0]
#         random_agent.setAgentColor("black")
# """
#             exec(code)
#             self.allies = True
#             print(self.allies)


            if behaviour == "Explorer":
                self.list_priorities = {"Move": {"To_Planet": True, "To_Player":False}, "Factory": 0, "Upgrade": {"Damage": False, "Factory":False}, "Weapon": 0}
            if behaviour == "Chaser":
                self.list_priorities = {"Weapon": 0, "Move": {"To_Planet": False, "To_Player":True}, "Upgrade": {"Damage": True, "Factory":False} , "Factory": 0}
            if behaviour == "Farmer":
                self.list_priorities = {"Factory": 0, "Upgrade": {"Damage": False, "Factory":True}, "Move":{"To_Planet": True, "To_Player":False} , "Weapon":0}

Ahora mismo el mas fuerte es el farmer, porque siempre es el que mas fabricas tiene y el que mas puntos estelares gana, he intentado nerfearle subiendole los precios de crear fabricas para que sean exponenciales
El chaser he conseguido balancearle haciendo que si lucha con alguien con economia negativa gene dinero y tecnologia y no haga un porcentaje negativo y le salga ganancia negativa de la lucha 

Tengo quer crear una mejora que sea para que no te afecten las taxes de los planetas, el problema es que nunca va a tener dinero suficiente como para desarrollarla 
El explorer ha pasado a ser el mas flojo porque no pueden mantener los planetas y siempre tienen balance de oro negativo y solo se pueedn mover y no tienen arma construida

Hay un bug que ocurre cuando un planeta se resetea y se borra, a veces no se resetea correctamente y todavia no he onseguido sacar porque 


Metodo que utilizaba para agregar atributos 
    # Método para añadir de manera dinámica atributos al modelo o al agente
    def _addAttribute(self, class_name, attribute_name, new_type, value, id=None):
        if new_type == "int":
            value = int(value)
        elif new_type == "float":
            value = float(value)
        elif new_type == "bool":
            if value == "true":
                value = True
            elif value == "false":
                value = False
        if class_name == "m":
            setattr(self, attribute_name, value)
        elif class_name == "a":
            agent_selected = self.list_agents[int(id)]
            setattr(agent_selected, attribute_name, value)
            print(agent_selected.__getattribute__(attribute_name))

            
Con este metodo puedo establecer de manera dinamica todos los comportamientos como quiera

    # Metodo para establecer los comportamientos de los agentes
    def setPlayerBehaviour(self):
        name_behaviour = input("Choose a name for the behaviour: ").lower()
        name_behaviour = name_behaviour.capitalize()
        if name_behaviour not in POSSIBLE_BEHAVIOURS:
            is_random = input("Do you want a random behaviour?. (y/n): ").lower()
            if is_random == "y":
                self.setBehaviour(name_behaviour, random_flag=True)
            else:
                self.setBehaviour(name_behaviour)
        else:
            self.setBehaviour(name_behaviour)


Tengo que ver como evitrar que si no hay espacio en el tablero siga añadiendo, con los valores de ahora mismo el limite está en 300 agentes en la simulación hasta 
que se quede dentro de un bucle infinito buscando espacio para los nuevos agentes 

Tendrá que tener más comportamietos se pueden añadir aleatorios o estableciendo la funcionalidad que se quiera,

****como por ejemplo un CIENTIFICO (tendrá menos coste al efectuar mejoras y tendrá nuevas opciones como moverse más de una casilla)
****Otro puede ser el PACIFISTA que evite el uso de armas y huya del combate siempre que pueda

    # Comportamientos preestablecidos para los tres comportamientos iniciales
            if behaviour == "Explorer":
                self.dict_actions["Move"]["To_Planet"] = True
                self.list_priorities = ["Move", "Factory", "Upgrade", "Weapon"]
            if behaviour == "Chaser":
                self.dict_actions["Move"]["To_Player"] = True
                self.dict_actions["Upgrade"]["Damage"] = True
                self.list_priorities = ["Weapon", "Upgrade", "Move", "Factory"]
            if behaviour == "Farmer":
                self.dict_actions["Upgrade"]["Factory"] = True
                self.list_priorities = ["Factory", "Upgrade", "Move", "Weapon"]

 
 Comentario en la clase de behaviours en el metodo act       
    """
        Tendría que determinar cual es la acción que va a realizar de su lista de prioridades y devolver el primer valor, pero si no puedo realizarlo tendría que devolver el siguiente
        Así en la clase principal solo tendría el bucle para los agentes y un while hasta que se complete la acción mientras que no haya aceptado la acción no sale del bucle
        pero tendría que hacer las comprobaciones igualemnte por lo que no soluciono nada y encima añado un bucle a la ejecució, a no ser que la comprobación la haga desde este metodo
        Para ello tengo que acceder a la información del agente... 
        """

Tengo que poder implementar el polimorfismo con la clase behaviours para poder crear de una manera simple los comportamientos 
Tengo que hacer que el agente dependiendo de su comportamiento elija una acción, el problema es que tiene que tener en cuenta su entorno, por lo que debo pasarle informacion del modelo o hacerlo desde el modelo

Puedo hacer que los agentes siempre se muevan hacia los planetas más cercanos o hacía los que más recurosos tienen y si ese planeta lo ha habitado otro agente ir a por el agente que tiene ese planeta 

Cambios 23/05 para poder revertirlos si algo sale mal
Crear un método para obtener la información más importante del entorno (Ganador(el que mas stellarPoints), el que tenga la peor arma, mas oro, mas tecnologia, el que mas planetas tenga)

Metodo para que el agente desde su propia clase pueda obtener la lista con el contexto de todso los agentes y no hacerlo desde el modelo
    # Método para que el agente consiga todo el contexto sobre los agentes y los planetas en la simulacion 
    def getContext(self):
        agent_set = self.model.get_agents_of_type(Player)
        list_agent_attributes = []
        list_planet_attributes = []
        for agent in agent_set:
            if agent == self:
                # Si el agente es el mismo no guardo sus variables porque ya las se 
                continue
            agent_attributes = agent.getAgentInfo()
            list_agent_attributes.append(agent_attributes)
        for planet in self.model.get_agents_of_type(Planet):
            planet_attributes = planet.getPlanetInfo()
            list_planet_attributes.append(planet_attributes)

        return list_agent_attributes, list_planet_attributes